// Code generated by go generate; DO NOT EDIT.
package input

import (
	"fmt"
	"os"
)

// AD15AirfoilInfo
type AD15AirfoilInfo struct {
	InterpOrd  int                        // Interpolation order to use for quasi-steady table lookup {1=linear; 3=cubic spline; "default"} [default=3]
	NonDimArea float64                    // The non-dimensional area of the airfoil (set to 1.0 if unsure or unneeded)
	NumCoords  int                        // The number of coordinates in the airfoil shape file.  Set to zero if coordinates not included.
	BL_file    string                     // The file name including the boundary layer characteristics of the profile. Ignored if the aeroacoustic module is not called.
	NumTabs    int                        // Number of airfoil tables in this file.  Each table must have lines for Re and Ctrl.
	Re         float64                    // Reynolds numbers in millions
	Ctrl       int                        // Control setting (must be 0 for current AirfoilInfo)
	InclUAdata bool                       // Is unsteady aerodynamics data included in this table? If TRUE, then include 30 UA coeffs below this line
	Alpha0     float64                    // 0-lift angle of attack, depends on airfoil.
	Alpha1     float64                    // Angle of attack at f=0.7, (approximately the stall angle) for AOA>alpha0.
	Alpha2     float64                    // Angle of attack at f=0.7, (approximately the stall angle) for AOA<alpha0.
	Eta_e      float64                    // Recovery factor in the range [0.85 - 0.95] used only for UAMOD=1, it is set to 1 in the code when flookup=True.
	C_nalpha   float64                    // Slope of the 2D normal force coefficient curve in the linear region of the polar.
	T_f0       float64                    // Intial value of the time constant associated with Df in the expression of Df and f'. Default value = 3.
	T_V0       float64                    // Intial value of the time constant associated with the vortex lift decay process; it is used in the expression of Cvn. It depends on Re,M, and airfoil class. Default value= 6.
	T_p        float64                    // Boundary-layer,leading edge pressure gradient time constant in the expression of Dp. It should be tuned based on airfoil experimental data. Default =1.7.
	T_VL       float64                    // Intial value of the time constant associated with the vortex advection process; it represents the non-dimensional time in semi-chords, needed for a vortex to travel from LE to trailing edge (TE); it is used in the expression of Cvn. It depends on Re, M (weakly), and airfoil. Value's range = [6; 13]; default value= 11.
	B1         float64                    // Constant in the expression of phi_alpha^c and phi_q^c;  from experimental results, it was set to 0.14. This value is relatively insensitive for thin airfoils, but may be different for turbine airfoils.
	B2         float64                    // Constant in the expression of phi_alpha^c and phi_q^c;  from experimental results, it was set to 0.53. This value is relatively insensitive for thin airfoils, but may be different for turbine airfoils.
	B5         float64                    // Constant in the expression of K'''_q,Cm_q^nc, and k_m,q; from  experimental results, it was set to 5.
	A1         float64                    // Constant in the expression of phi_alpha^c and phi_q^c;  from experimental results, it was set to 0.3. This value is relatively insensitive for thin airfoils, but may be different for turbine airfoils.
	A2         float64                    // Constant in the expression of phi_alpha^c and phi_q^c;  from experimental results, it was set to 0.7. This value is relatively insensitive for thin airfoils, but may be different for turbine airfoils.
	A5         float64                    // Constant in the expression of K'''_q,Cm_q^nc, and k_m,q; from  experimental results, it was set to 1.
	S1         float64                    // Constant in the f curve bestfit for alpha0<=AOA<=alpha1;by definition it depends on the airfoil. Ignored if UAMod<>1.
	S2         float64                    // Constant in the f curve bestfit for         AOA>alpha1;by definition it depends on the airfoil. Ignored if UAMod<>1.
	S3         float64                    // Constant in the f curve bestfit for alpha2<=AOA<alpha0;by definition it depends on the airfoil. Ignored if UAMod<>1.
	S4         float64                    // Constant in the f curve bestfit for         AOA<alpha2;by definition it depends on the airfoil. Ignored if UAMod<>1.
	Cn1        float64                    // Critical value of C0n at leading edge separation. It should be extracted from airfoil data at a given Mach and Reynolds number. It can be calculated from the static value of Cn at either the break in the pitching moment or the loss of chord force at the onset of stall. It is close to the condition of maximum lift of the airfoil at low Mach numbers.
	Cn2        float64                    // As Cn1 for negative AOAs.
	St_sh      float64                    // Strouhal's shedding frequency constant; default =0.19.
	Cd0        float64                    // 2D drag coefficient value at 0-lift.
	Cm0        float64                    // 2D pitching moment coeffcient about 1/4-chord location, at 0-lift, positive if nose up.
	K0         float64                    // Constant in the \hat(x)_cp curve best-fit; = (\hat(x)_AC-0.25). Ignored if UAMod<>1.
	K1         float64                    // Constant in the \hat(x)_cp curve best-fit. Ignored if UAMod<>1.
	K2         float64                    // Constant in the \hat(x)_cp curve best-fit. Ignored if UAMod<>1.
	K3         float64                    // Constant in the \hat(x)_cp curve best-fit. Ignored if UAMod<>1.
	K1_hat     float64                    // Constant in the expression of Cc due to leading edge vortex effects. Ignored if UAMod<>1.
	X_cp_bar   float64                    // Constant in the expression of \hat(x)_cp^v. Default value =0.2. Ignored if UAMod<>1.
	UACutout   float64                    // Angle of attack above which unsteady aerodynamics are disabled (deg). [Specifying the string "Default" sets UACutout to 45 degrees]
	FiltCutOff float64                    // Cut-off frequency (-3 dB corner frequency) for low-pass filtering the AoA input to UA, as well as the 1st and 2nd derivatives (Hz) [default = 20]
	NumAlf     int                        // Number of data lines in the following CoeffData table
	CoeffData  []AD15AirfoilInfoCoeffData //
	Defaults   map[string]struct{}
}

// AD15AirfoilInfoCoeffData
type AD15AirfoilInfoCoeffData struct {
	Alpha float64 //
	Cl    float64 //
	Cd    float64 //
	Cm    float64 //
}

func NewAD15AirfoilInfo() *AD15AirfoilInfo {
	return &AD15AirfoilInfo{
		Defaults: map[string]struct{}{},
	}
}

func (s *AD15AirfoilInfo) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, AD15AirfoilInfoSchema, lines)
}

func ReadAD15AirfoilInfo(path string) (*AD15AirfoilInfo, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewAD15AirfoilInfo()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *AD15AirfoilInfo) Format() (text []byte, err error) {
	return formatText(s, AD15AirfoilInfoSchema)
}

func (s *AD15AirfoilInfo) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("AD15AirfoilInfo.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// AeroDyn14
type AeroDyn14 struct {

	// AeroDyn 14 Input File
	Title        string          //
	StallMod     string          // Dynamic stall included
	UseCm        string          // Use aerodynamic pitching moment model?
	InfModel     string          // Inflow model [DYNIN or EQUIL]
	IndModel     string          // Induction-factor model [NONE or WAKE or SWIRL]
	AToler       float64         // Induction-factor tolerance (convergence criteria) (-)
	TLModel      string          // Tip-loss model (EQUIL only) [PRANDtl, GTECH, or NONE]
	HLModel      string          // Hub-loss model (EQUIL only) [PRANdtl or NONE]
	TwrShad      float64         // Tower-shadow velocity deficit (-)
	ShadHWid     float64         // Tower-shadow half width (m)
	T_Shad_Refpt float64         // Tower-shadow reference point (m)
	AirDens      float64         // Air density (kg/m^3)
	KinVisc      float64         // Kinematic air viscosity [CURRENTLY IGNORED] (m^2/sec)
	DTAero       float64         // Time interval for aerodynamic calculations (sec)
	NumFoil      int             // Number of airfoil files (-)
	FoilNm       []string        // Names of the airfoil files [NumFoil lines] (quoted strings)
	BldNodes     int             // Number of blade nodes used for analysis (-)
	BlNd         []AeroDyn14BlNd //
	Defaults     map[string]struct{}
}

// AeroDyn14BlNd
type AeroDyn14BlNd struct {
	RNodes   float64 //
	AeroTwst float64 //
	DRNodes  float64 //
	Chord    float64 //
	NFoil    int     //
	PrnElm   string  //
}

func NewAeroDyn14() *AeroDyn14 {
	return &AeroDyn14{
		Defaults: map[string]struct{}{},
	}
}

func (s *AeroDyn14) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, AeroDyn14Schema, lines)
}

func ReadAeroDyn14(path string) (*AeroDyn14, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewAeroDyn14()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *AeroDyn14) Format() (text []byte, err error) {
	return formatText(s, AeroDyn14Schema)
}

func (s *AeroDyn14) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("AeroDyn14.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// AeroDyn15
type AeroDyn15 struct {

	// AeroDyn 15 Input File
	Title string //

	// General Options
	Echo         bool    // Echo the input to "<rootname>.AD.ech"?
	DTAero       float64 // Time interval for aerodynamic calculations {or "default"}
	WakeMod      int     // Type of wake/induction model [WakeMod cannot be 2 or 3 when linearizing]
	AFAeroMod    int     // Type of blade airfoil aerodynamics model[AFAeroMod must be 1 when linearizing]
	TwrPotent    int     // Type tower influence on wind based on potential flow around the tower
	TwrShadow    int     // Calculate tower influence on wind based on downstream tower shadow
	TwrAero      bool    // Calculate tower aerodynamic loads?
	FrozenWake   bool    // Assume frozen wake during linearization? [used only when WakeMod=1 and when linearizing]
	CavitCheck   bool    // Perform cavitation check? [AFAeroMod must be 1 when CavitCheck=true]
	CompAA       bool    // Flag to compute AeroAcoustics calculation [used only when WakeMod = 1 or 2]
	AA_InputFile string  // AeroAcoustics input file [used only when CompAA=true]

	// Environmental Conditions
	AirDens  float64 // Air density
	KinVisc  float64 // Kinematic viscosity of working fluid
	SpdSound float64 // Speed of sound in working fluid
	Patm     float64 // Atmospheric pressure [used only when CavitCheck=True]
	Pvap     float64 // Vapour pressure of working fluid [used only when CavitCheck=True]

	// Blade-Element/Momentum Theory Options [unused when WakeMod=0 or 3]
	SkewMod       int     // Type of skewed-wake correction model [unused when WakeMod=0 or 3]
	SkewModFactor float64 // Constant used in Pitt/Peters skewed wake model {or "default" is 15/32*pi} (-) [used only when SkewMod=2; unused when WakeMod=0 or 3]
	TipLoss       bool    // Use the Prandtl tip-loss model? [unused when WakeMod=0 or 3]
	HubLoss       bool    // Use the Prandtl hub-loss model? [unused when WakeMod=0 or 3]
	TanInd        bool    // Include tangential induction in BEMT calculations? [unused when WakeMod=0 or 3]
	AIDrag        bool    // Include the drag term in the axial-induction calculation? [unused when WakeMod=0 or 3]
	TIDrag        bool    // Include the drag term in the tangential-induction calculation? [unused when WakeMod=0,3 or TanInd=FALSE]
	IndToler      float64 // Convergence tolerance for BEMT nonlinear solve residual equation {or "default"} (-) [unused when WakeMod=0 or 3]
	MaxIter       int     // Maximum number of iteration steps (-) [unused when WakeMod=0]

	// Dynamic Blade-Element/Momentum Theory Options [used only when WakeMod=2]
	DBEMT_Mod  int     // Type of dynamic BEMT (DBEMT) model [used only when WakeMod=2]
	Tau1_const float64 // Time constant for DBEMT (s) [used only when WakeMod=2 and DBEMT_Mod=1]

	// OLAF -- cOnvecting LAgrangian Filaments (Free Vortex Wake) Theory Options [used only when WakeMod=3]
	OLAFInputFileName string // Input file for OLAF [used only when WakeMod=3]

	// Beddoes-Leishman Unsteady Airfoil Aerodynamics Options [used only when AFAeroMod=2]
	UAMod   int  // Unsteady Aero Model Switch (switch) {1=Baseline model (Original), 2=Gonzalez's variant (changes in Cn,Cc,Cm), 3=Minnema/Pierce variant (changes in Cc and Cm)} [used only when AFAeroMod=2]
	FLookup bool // Flag to indicate whether a lookup for f' will be calculated (TRUE) or whether best-fit exponential equations will be used (FALSE); if FALSE S1-S4 must be provided in airfoil input files (flag) [used only when AFAeroMod=2]

	// Airfoil Information
	AFTabMod    int      // Interpolation method for multiple airfoil tables {1=1D interpolation on AoA (first table only); 2=2D interpolation on AoA and Re; 3=2D interpolation on AoA and UserProp} (-)
	InCol_Alfa  int      // The column in the airfoil tables that contains the angle of attack (-)
	InCol_Cl    int      // The column in the airfoil tables that contains the lift coefficient (-)
	InCol_Cd    int      // The column in the airfoil tables that contains the drag coefficient (-)
	InCol_Cm    int      // The column in the airfoil tables that contains the pitching-moment coefficient; use zero if there is no Cm column (-)
	InCol_Cpmin int      // The column in the airfoil tables that contains the Cpmin coefficient; use zero if there is no Cpmin column (-)
	NumAFfiles  int      // Number of airfoil files used (-)
	AFNames     []string // Airfoil file names (NumAFfiles lines) (quoted strings)

	// Rotor/Blade Properties
	UseBlCm   bool   // Include aerodynamic pitching moment in calculations?  (flag)
	ADBlFile1 string // Name of file containing distributed aerodynamic properties for Blade #1 (-)
	ADBlFile2 string // Name of file containing distributed aerodynamic properties for Blade #2 (-) [unused if NumBl < 2]
	ADBlFile3 string // Name of file containing distributed aerodynamic properties for Blade #3 (-) [unused if NumBl < 3]

	// Tower Influence and Aerodynamics [used only when TwrPotent/=0, TwrShadow/=0, or TwrAero=True]
	NumTwrNds int                 // Number of tower nodes used in the analysis  (-) [used only when TwrPotent/=0, TwrShadow/=0, or TwrAero=True]
	TwrNodes  []AeroDyn15TwrNodes //

	// Outputs
	SumPrint bool     // Generate a summary file listing input options and interpolated properties to "<rootname>.AD.sum"?  (flag)
	NBlOuts  int      // Number of blade node outputs [0 - 9] (-)
	BlOutNd  []int    // Blade nodes whose values will be output  (-)
	NTwOuts  int      // Number of tower node outputs [0 - 9]  (-)
	TwOutNd  []int    // Tower nodes whose values will be output  (-)
	OutList  []string // The next line(s) contains a list of output parameters.  See OutListParameters.xlsx for a listing of available output channels, (-)
	Defaults map[string]struct{}
}

// AeroDyn15TwrNodes
type AeroDyn15TwrNodes struct {
	TwrElev float64 // (m)
	TwrDiam float64 // (m)
	TwrCd   float64 // (-)
	TwrTI   float64 // (used only with TwrShadow=2) (-)
}

func NewAeroDyn15() *AeroDyn15 {
	return &AeroDyn15{
		Defaults: map[string]struct{}{},
	}
}

func (s *AeroDyn15) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, AeroDyn15Schema, lines)
}

func ReadAeroDyn15(path string) (*AeroDyn15, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewAeroDyn15()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *AeroDyn15) Format() (text []byte, err error) {
	return formatText(s, AeroDyn15Schema)
}

func (s *AeroDyn15) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("AeroDyn15.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// AeroDynBlade
type AeroDynBlade struct {

	// AeroDyn Blade Input File
	Title string //

	// Blade Properties
	NumBlNds int                // Number of blade nodes used in the analysis (-)
	BlNd     []AeroDynBladeBlNd //
	Defaults map[string]struct{}
}

// AeroDynBladeBlNd
type AeroDynBladeBlNd struct {
	BlSpn    float64 // (m)
	BlCrvAC  float64 // (m)
	BlSwpAC  float64 // (m)
	BlCrvAng float64 // (deg)
	BlTwist  float64 // (deg)
	BlChord  float64 // (m)
	BlAFID   int     // (-)
}

func NewAeroDynBlade() *AeroDynBlade {
	return &AeroDynBlade{
		Defaults: map[string]struct{}{},
	}
}

func (s *AeroDynBlade) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, AeroDynBladeSchema, lines)
}

func ReadAeroDynBlade(path string) (*AeroDynBlade, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewAeroDynBlade()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *AeroDynBlade) Format() (text []byte, err error) {
	return formatText(s, AeroDynBladeSchema)
}

func (s *AeroDynBlade) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("AeroDynBlade.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// BeamDyn
type BeamDyn struct {

	// Beamdyn Input File
	Title string //

	// Simulation Control
	Echo             bool    // Echo input data to "<RootName>.ech"? (flag)
	QuasiStaticInit  bool    // Use quasi-static pre-conditioning with centripetal accelerations in initialization? (flag) [dynamic solve only]
	Rhoinf           float64 // Numerical damping parameter for generalized-alpha integrator
	Quadrature       int     // Quadrature method: 1=Gaussian; 2=Trapezoidal (switch)
	Refine           int     // Refinement factor for trapezoidal quadrature (-) [DEFAULT = 1; used only when quadrature=2]
	N_fact           int     // Factorization frequency for the Jacobian in N-R iteration(-) [DEFAULT = 5]
	DTBeam           float64 // Time step size (s)
	Load_retries     int     // Number of factored load retries before quitting the simulation [DEFAULT = 20]
	NRMax            int     // Max number of iterations in Newton-Raphson algorithm (-) [DEFAULT = 10]
	Stop_tol         float64 // Tolerance for stopping criterion (-) [DEFAULT = 1E-5]
	Tngt_stf_fd      bool    // Use finite differenced tangent stiffness matrix? (flag)
	Tngt_stf_comp    bool    // Compare analytical finite differenced tangent stiffness matrix? (flag)
	Tngt_stf_pert    float64 // Perturbation size for finite differencing (-) [DEFAULT = 1E-6]
	Tngt_stf_difftol float64 // Maximum allowable relative difference between analytical and fd tangent stiffness (-); [DEFAULT = 0.1]
	RotStates        bool    // Orient states in the rotating frame during linearization? (flag) [used only when linearizing]

	// Geometry Parameter
	Member_total int                // Total number of members (-)
	Kp_total     int                // Total number of key points (-) [must be at least 3]
	Members      [][]BeamDynMembers //

	// Mesh Parameter
	Order_elem int // Order of interpolation (basis) function (-)

	// Material Parameter
	BldFile string // Name of file containing properties for blade (quoted string)

	// Pitch Actuator Parameters
	UsePitchAct bool    // Whether a pitch actuator should be used (flag)
	PitchJ      float64 // Pitch actuator inertia (kg-m^2) [used only when UsePitchAct is true]
	PitchK      float64 // Pitch actuator stiffness (kg-m^2/s^2) [used only when UsePitchAct is true]
	PitchC      float64 // Pitch actuator damping (kg-m^2/s) [used only when UsePitchAct is true]

	// Outputs
	SumPrint  bool     // Print summary data to "<RootName>.sum" (flag)
	OutFmt    string   // Format used for text tabular output, excluding the time channel.
	NNodeOuts int      // Number of nodes to output to file [0 - 9] (-)
	OutNd     []int    // Nodes whose values will be output  (-)
	OutList   []string // The next line(s) contains a list of output parameters.  See OutListParameters.xlsx for a listing of available output channels, (-)
	Defaults  map[string]struct{}
}

// BeamDynMembers
type BeamDynMembers struct {
	Kp_xr         float64 //
	Kp_yr         float64 //
	Kp_zr         float64 //
	Initial_twist float64 //
}

func NewBeamDyn() *BeamDyn {
	return &BeamDyn{
		Defaults: map[string]struct{}{},
	}
}

func (s *BeamDyn) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, BeamDynSchema, lines)
}

func ReadBeamDyn(path string) (*BeamDyn, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewBeamDyn()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *BeamDyn) Format() (text []byte, err error) {
	return formatText(s, BeamDynSchema)
}

func (s *BeamDyn) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("BeamDyn.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// BeamDynBlade
type BeamDynBlade struct {

	// BeamDyn Blade Input File
	Title string //

	// Blade Parameters
	Station_total int // Number of blade input stations
	Damp_type     int // Damping type: 0: no damping; 1: damped

	// Damping Coefficient
	Mu []float64 //

	// Distributed Properties
	DistProps []BeamDynBladeDistProps //
	Defaults  map[string]struct{}
}

// BeamDynBladeDistProps
type BeamDynBladeDistProps struct {
	Station_eta      float64     //
	Stiffness_matrix [][]float64 //
	Mass_matrix      [][]float64 //
}

func NewBeamDynBlade() *BeamDynBlade {
	return &BeamDynBlade{
		Defaults: map[string]struct{}{},
	}
}

func (s *BeamDynBlade) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, BeamDynBladeSchema, lines)
}

func ReadBeamDynBlade(path string) (*BeamDynBlade, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewBeamDynBlade()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *BeamDynBlade) Format() (text []byte, err error) {
	return formatText(s, BeamDynBladeSchema)
}

func (s *BeamDynBlade) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("BeamDynBlade.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// ElastoDyn
type ElastoDyn struct {

	// ElastoDyn Input File
	Title string //

	// Simulation Control
	Echo   bool    // Echo input data to <RootName>.ech
	Method int     // Integration method
	DT     float64 // Integration time step

	// Degrees Of Freedom
	FlapDOF1  bool // First flapwise blade mode DOF
	FlapDOF2  bool // Second flapwise blade mode DOF
	EdgeDOF   bool // First edgewise blade mode DOF
	TeetDOF   bool // Rotor-teeter DOF [unused for 3 blades]
	DrTrDOF   bool // Drivetrain rotational-flexibility DOF
	GenDOF    bool // Generator DOF
	YawDOF    bool // Yaw DOF
	TwFADOF1  bool // First fore-aft tower bending-mode DOF
	TwFADOF2  bool // Second fore-aft tower bending-mode DOF
	TwSSDOF1  bool // First side-to-side tower bending-mode DOF
	TwSSDOF2  bool // Second side-to-side tower bending-mode DOF
	PtfmSgDOF bool // Platform horizontal surge translation DOF
	PtfmSwDOF bool // Platform horizontal sway translation DOF
	PtfmHvDOF bool // Platform vertical heave translation DOF
	PtfmRDOF  bool // Platform roll tilt rotation DOF
	PtfmPDOF  bool // Platform pitch tilt rotation DOF
	PtfmYDOF  bool // Platform yaw rotation DOF

	// Initial Conditions
	OoPDefl   float64 // Initial out-of-plane blade-tip displacement
	IPDefl    float64 // Initial in-plane blade-tip deflection
	BlPitch1  float64 // Blade 1 initial pitch
	BlPitch2  float64 // Blade 2 initial pitch
	BlPitch3  float64 // Blade 3 initial pitch [unused for 2 blades]
	TeetDefl  float64 // Initial or fixed teeter angle [unused for 3 blades]
	Azimuth   float64 // Initial azimuth angle for blade 1
	RotSpeed  float64 // Initial or fixed rotor speed
	NacYaw    float64 // Initial or fixed nacelle-yaw angle
	TTDspFA   float64 // Initial fore-aft tower-top displacement
	TTDspSS   float64 // Initial side-to-side tower-top displacement
	PtfmSurge float64 // Initial or fixed horizontal surge translational displacement of platform
	PtfmSway  float64 // Initial or fixed horizontal sway translational displacement of platform
	PtfmHeave float64 // Initial or fixed vertical heave translational displacement of platform
	PtfmRoll  float64 // Initial or fixed roll tilt rotational displacement of platform
	PtfmPitch float64 // Initial or fixed pitch tilt rotational displacement of platform
	PtfmYaw   float64 // Initial or fixed yaw rotational displacement of platform

	// Turbine Configuration
	NumBl     int     // Number of blades
	TipRad    float64 // The distance from the rotor apex to the blade tip
	HubRad    float64 // The distance from the rotor apex to the blade root
	PreCone1  float64 // Blade 1 cone angle
	PreCone2  float64 // Blade 2 cone angle
	PreCone3  float64 // Blade 3 cone angle [unused for 2 blades]
	HubCM     float64 // Distance from rotor apex to hub mass [positive downwind]
	UndSling  float64 // Undersling length [distance from teeter pin to the rotor apex] , Unit:"meters"[unused for 3 blades]
	Delta3    float64 // Delta-3 angle for teetering rotors [unused for 3 blades]
	AzimB1Up  float64 // Azimuth value to use for I/O when blade 1 points up
	OverHang  float64 // Distance from yaw axis to rotor apex [3 blades] or teeter pin [2 blades]
	ShftGagL  float64 // Distance from rotor apex [3 blades] or teeter pin [2 blades] to shaft strain gages [positive for upwind rotors]
	ShftTilt  float64 // Rotor shaft tilt angle
	NacCMxn   float64 // Downwind distance from the tower-top to the nacelle CM
	NacCMyn   float64 // Lateral  distance from the tower-top to the nacelle CM
	NacCMzn   float64 // Vertical distance from the tower-top to the nacelle CM
	NcIMUxn   float64 // Downwind distance from the tower-top to the nacelle IMU
	NcIMUyn   float64 // Lateral  distance from the tower-top to the nacelle IMU
	NcIMUzn   float64 // Vertical distance from the tower-top to the nacelle IMU
	Twr2Shft  float64 // Vertical distance from the tower-top to the rotor shaft
	TowerHt   float64 // Height of tower above ground level [onshore] or MSL [offshore]
	TowerBsHt float64 // Height of tower base above ground level [onshore] or MSL [offshore]
	PtfmCMxt  float64 // Downwind distance from the ground level [onshore] or MSL [offshore] to the platform CM
	PtfmCMyt  float64 // Lateral distance from the ground level [onshore] or MSL [offshore] to the platform CM
	PtfmCMzt  float64 // Vertical distance from the ground level [onshore] or MSL [offshore] to the platform CM
	PtfmRefzt float64 // Vertical distance from the ground level [onshore] or MSL [offshore] to the platform reference point

	// Mass And Inertia
	TipMass1  float64 // Tip-brake mass, blade 1
	TipMass2  float64 // Tip-brake mass, blade 2
	TipMass3  float64 // Tip-brake mass, blade 3 [unused for 2 blades]
	HubMass   float64 // Hub mass
	HubIner   float64 // Hub inertia about rotor axis [3 blades] or teeter axis [2 blades]
	GenIner   float64 // Generator inertia about HSS
	NacMass   float64 // Nacelle mass
	NacYIner  float64 // Nacelle inertia about yaw axis
	YawBrMass float64 // Yaw bearing mass
	PtfmMass  float64 // Platform mass
	PtfmRIner float64 // Platform inertia for roll tilt rotation about the platform CM
	PtfmPIner float64 // Platform inertia for pitch tilt rotation about the platform CM
	PtfmYIner float64 // Platform inertia for yaw rotation about the platform CM

	// Blade
	BldNodes int    // Number of blade nodes (per blade) used for analysis
	BldFile1 string // Name of file containing properties for blade 1 (quoted string)
	BldFile2 string // Name of file containing properties for blade 2 (quoted string)
	BldFile3 string // Name of file containing properties for blade 3 (quoted string) [unused for 2 blades]

	// Rotor-Teeter
	TeetMod  int     // Rotor-teeter spring/damper model (switch) [unused for 3 blades]
	TeetDmpP float64 // Rotor-teeter damper position [used only for 2 blades and when TeetMod=1]
	TeetDmp  float64 // Rotor-teeter damping constant [used only for 2 blades and when TeetMod=1]
	TeetCDmp float64 // Rotor-teeter rate-independent Coulomb-damping moment (N-m) [used only for 2 blades and when TeetMod=1]
	TeetSStP float64 // Rotor-teeter soft-stop position [used only for 2 blades and when TeetMod=1]
	TeetHStP float64 // Rotor-teeter hard-stop position [used only for 2 blades and when TeetMod=1]
	TeetSSSp float64 // Rotor-teeter soft-stop linear-spring constant [used only for 2 blades and when TeetMod=1]
	TeetHSSp float64 // Rotor-teeter hard-stop linear-spring constant [used only for 2 blades and when TeetMod=1]

	// Drivetrain
	GBoxEff  float64 // Gearbox efficiency
	GBRatio  float64 // Gearbox ratio
	DTTorSpr float64 // Drivetrain torsional spring
	DTTorDmp float64 // Drivetrain torsional damper

	// Furling
	Furling  bool   // Read in additional model properties for furling turbine [must currently be FALSE)
	FurlFile string // Name of file containing furling properties (quoted string) [unused when Furling=False]

	// Tower
	TwrNodes int    // Number of tower nodes used for analysis (-)
	TwrFile  string // Name of file containing tower properties (quoted string)

	// Output
	SumPrint bool     // Print summary data to '<RootName>.sum'
	OutFile  int      // Switch to determine where output will be placed: {1: in module output file only; 2: in glue code output file only; 3: both} (currently unused)
	TabDelim bool     // Use tab delimiters in text tabular output file? (currently unused)
	OutFmt   string   // Format used for text tabular output (except time).  Resulting field should be 10 characters. (quoted string) (currently unused)
	TStart   float64  // Time to begin tabular output (s) (currently unused)
	DecFact  int      // Decimation factor for tabular output {1: output every time step} (-) (currently unused)
	NTwGages int      // Number of tower nodes that have strain gages for output [0 to 9] (-)
	TwrGagNd []int    // List of tower nodes that have strain gages [1 to TwrNodes] (-) [unused if NTwGages=0]
	NBlGages int      // Number of blade nodes that have strain gages for output [0 to 9] (-)
	BldGagNd []int    // List of blade nodes that have strain gages [1 to BldNodes] (-) [unused if NBlGages=0]
	OutList  []string // The next line(s) contains a list of output parameters.  See OutListParameters.xlsx for a listing of available output channels, (-)
	Defaults map[string]struct{}
}

func NewElastoDyn() *ElastoDyn {
	return &ElastoDyn{
		Defaults: map[string]struct{}{},
	}
}

func (s *ElastoDyn) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, ElastoDynSchema, lines)
}

func ReadElastoDyn(path string) (*ElastoDyn, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewElastoDyn()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *ElastoDyn) Format() (text []byte, err error) {
	return formatText(s, ElastoDynSchema)
}

func (s *ElastoDyn) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("ElastoDyn.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// ElastoDynBlade
type ElastoDynBlade struct {

	// ElastoDyn Blade Input File
	Title string //

	// Blade Parameters
	NBlInpSt  int     // Number of blade input stations
	BldFlDmp1 float64 // Blade flap mode #1 structural damping in percent of critical
	BldFlDmp2 float64 // Blade flap mode #2 structural damping in percent of critical
	BldEdDmp1 float64 // Blade edge mode #1 structural damping in percent of critical

	// Blade Adjustment Factors
	FlStTunr1 float64 // Blade flapwise modal stiffness tuner, 1st mode
	FlStTunr2 float64 // Blade flapwise modal stiffness tuner, 2nd mode
	AdjBlMs   float64 // Factor to adjust blade mass density
	AdjFlSt   float64 // Factor to adjust blade flap stiffness
	AdjEdSt   float64 // Factor to adjust blade edge stiffness

	// Distributed Blade Properties
	BlInpSt []ElastoDynBladeBlInpSt //

	// Blade Mode Shapes
	BldFl1Sh2 float64 // Flap mode 1, coeff of x^2
	BldFl1Sh3 float64 //            , coeff of x^3
	BldFl1Sh4 float64 //            , coeff of x^4
	BldFl1Sh5 float64 //            , coeff of x^5
	BldFl1Sh6 float64 //            , coeff of x^6
	BldFl2Sh2 float64 // Flap mode 2, coeff of x^2
	BldFl2Sh3 float64 //            , coeff of x^3
	BldFl2Sh4 float64 //            , coeff of x^4
	BldFl2Sh5 float64 //            , coeff of x^5
	BldFl2Sh6 float64 //            , coeff of x^6
	BldEdgSh2 float64 // Edge mode 1, coeff of x^2
	BldEdgSh3 float64 //            , coeff of x^3
	BldEdgSh4 float64 //            , coeff of x^4
	BldEdgSh5 float64 //            , coeff of x^5
	BldEdgSh6 float64 //            , coeff of x^6
	Defaults  map[string]struct{}
}

// ElastoDynBladeBlInpSt
type ElastoDynBladeBlInpSt struct {
	BlFract   float64 //
	PitchAxis float64 //
	StrcTwst  float64 //
	BMassDen  float64 //
	FlpStff   float64 //
	EdgStff   float64 //
}

func NewElastoDynBlade() *ElastoDynBlade {
	return &ElastoDynBlade{
		Defaults: map[string]struct{}{},
	}
}

func (s *ElastoDynBlade) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, ElastoDynBladeSchema, lines)
}

func ReadElastoDynBlade(path string) (*ElastoDynBlade, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewElastoDynBlade()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *ElastoDynBlade) Format() (text []byte, err error) {
	return formatText(s, ElastoDynBladeSchema)
}

func (s *ElastoDynBlade) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("ElastoDynBlade.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// ElastoDynTower
type ElastoDynTower struct {

	// ElastoDyn Tower Input File
	Title string //

	// Tower Parameters
	NTwInpSt  int     // Number of input stations to specify tower geometry
	TwrFADmp1 float64 // Tower 1st fore-aft mode structural damping ratio
	TwrFADmp2 float64 // Tower 2nd fore-aft mode structural damping ratio
	TwrSSDmp1 float64 // Tower 1st side-to-side mode structural damping ratio
	TwrSSDmp2 float64 // Tower 2nd side-to-side mode structural damping ratio

	// Tower Adjustment Factors
	FAStTunr1 float64 // Tower fore-aft modal stiffness tuner, 1st mode
	FAStTunr2 float64 // Tower fore-aft modal stiffness tuner, 2nd mode
	SSStTunr1 float64 // Tower side-to-side stiffness tuner, 1st mode
	SSStTunr2 float64 // Tower side-to-side stiffness tuner, 2nd mode
	AdjTwMa   float64 // Factor to adjust tower mass density
	AdjFASt   float64 // Factor to adjust tower fore-aft stiffness
	AdjSSSt   float64 // Factor to adjust tower side-to-side stiffness

	// Distributed Tower Properties
	TwInpSt []ElastoDynTowerTwInpSt //

	// Tower Fore-Aft Mode Shapes
	TwFAM1Sh2 float64 // Mode 1, coefficient of x^2 term
	TwFAM1Sh3 float64 //       , coefficient of x^3 term
	TwFAM1Sh4 float64 //       , coefficient of x^4 term
	TwFAM1Sh5 float64 //       , coefficient of x^5 term
	TwFAM1Sh6 float64 //       , coefficient of x^6 term
	TwFAM2Sh2 float64 // Mode 2, coefficient of x^2 term
	TwFAM2Sh3 float64 //       , coefficient of x^3 term
	TwFAM2Sh4 float64 //       , coefficient of x^4 term
	TwFAM2Sh5 float64 //       , coefficient of x^5 term
	TwFAM2Sh6 float64 //       , coefficient of x^6 term

	// Tower Side-To-Side Mode Shapes
	TwSSM1Sh2 float64 // Mode 1, coefficient of x^2 term
	TwSSM1Sh3 float64 //       , coefficient of x^3 term
	TwSSM1Sh4 float64 //       , coefficient of x^4 term
	TwSSM1Sh5 float64 //       , coefficient of x^5 term
	TwSSM1Sh6 float64 //       , coefficient of x^6 term
	TwSSM2Sh2 float64 // Mode 2, coefficient of x^2 term
	TwSSM2Sh3 float64 //       , coefficient of x^3 term
	TwSSM2Sh4 float64 //       , coefficient of x^4 term
	TwSSM2Sh5 float64 //       , coefficient of x^5 term
	TwSSM2Sh6 float64 //       , coefficient of x^6 term
	Defaults  map[string]struct{}
}

// ElastoDynTowerTwInpSt
type ElastoDynTowerTwInpSt struct {
	HtFract  float64 // Fractional height of the flexible portion of tower for a given input station
	TMassDen float64 // Tower mass density for a given input station
	TwFAStif float64 // Tower fore-aft stiffness for a given input station
	TwSSStif float64 // Tower side-to-side stiffness for a given input station
}

func NewElastoDynTower() *ElastoDynTower {
	return &ElastoDynTower{
		Defaults: map[string]struct{}{},
	}
}

func (s *ElastoDynTower) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, ElastoDynTowerSchema, lines)
}

func ReadElastoDynTower(path string) (*ElastoDynTower, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewElastoDynTower()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *ElastoDynTower) Format() (text []byte, err error) {
	return formatText(s, ElastoDynTowerSchema)
}

func (s *ElastoDynTower) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("ElastoDynTower.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// FAST
type FAST struct {

	// OpenFAST Input File
	Title string // File title

	// Simulation Control
	Echo        bool    // Echo input data to <RootName>.ech
	AbortLevel  string  // Error level when simulation should abort
	TMax        float64 // Total run time
	DT          float64 // Recommended module time step
	InterpOrder int     // Interpolation order for input/output time history
	NumCrctn    int     // Number of correction iterations {0=explicit calculation, i.e., no corrections}
	DT_UJac     float64 // Time between calls to get Jacobians
	UJacSclFact float64 // Scaling factor used in Jacobians

	// Feature switches and flags
	CompElast   int // Compute structural dynamics
	CompInflow  int // Compute inflow wind velocities
	CompAero    int // Compute aerodynamic loads
	CompServo   int // Compute control and electrical-drive dynamics
	CompHydro   int // Compute hydrodynamic loads
	CompSub     int // Compute sub-structural dynamics
	CompMooring int // Compute mooring system
	CompIce     int // Compute ice loads
	MHK         int // MHK turbine type

	// Environmental Conditions
	Gravity  float64 // Gravitational acceleration
	AirDens  float64 // Air density
	WtrDens  float64 // Water density
	KinVisc  float64 // Kinematic viscosity of working fluid
	SpdSound float64 // Speed of sound in working fluid
	Patm     float64 // Atmospheric pressure [used only for an MHK turbine cavitation check]
	Pvap     float64 // Vapour pressure of working fluid [used only for an MHK turbine cavitation check]
	WtrDpth  float64 // Water depth
	MSL2SWL  float64 // Offset between still-water level and mean sea level [positive upward]

	// Input Files
	EDFile      string // Name of file containing ElastoDyn input parameters
	BDBldFile1  string // Name of file containing BeamDyn input parameters for blade 1
	BDBldFile2  string // Name of file containing BeamDyn input parameters for blade 2
	BDBldFile3  string // Name of file containing BeamDyn input parameters for blade 3
	InflowFile  string // Name of file containing inflow wind input parameters
	AeroFile    string // Name of file containing aerodynamic input parameters
	ServoFile   string // Name of file containing control and electrical-drive input parameters
	HydroFile   string // Name of file containing hydrodynamic input parameters
	SubFile     string // Name of file containing sub-structural input parameters
	MooringFile string // Name of file containing mooring system input parameters
	IceFile     string // Name of file containing ice input parameters

	// Output
	SumPrint   bool    // Print summary data to '<RootName>.sum'
	SttsTime   float64 // Amount of time between screen status messages
	ChkptTime  float64 // Amount of time between creating checkpoint files for potential restart
	DT_Out     float64 // Time step for tabular output (or "default")
	TStart     float64 // Time to begin tabular output
	OutFileFmt int     // Format for tabular (time-marching) output file
	TabDelim   bool    // Use tab delimiters in text tabular output file?
	OutFmt     string  // Format used for text tabular output, excluding the time channel.  Resulting field should be 10 characters

	// Linearization
	Linearize  bool      // Linearization analysis
	CalcSteady bool      // Calculate a steady-state periodic operating point before linearization?
	TrimCase   int       // Controller parameter to be trimmed
	TrimTol    float64   // Tolerance for the rotational speed convergence
	TrimGain   float64   // Proportional gain for the rotational speed error (>0) (rad/(rad/s) for yaw or pitch; Nm/(rad/s) for torque)
	Twr_Kdmp   float64   // Damping factor for the tower
	Bld_Kdmp   float64   // Damping factor for the blades
	NLinTimes  int       // Number of times to linearize [>=1]
	LinTimes   []float64 // List of times at which to linearize [1 to NLinTimes] [used only when Linearize=True and CalcSteady=False]
	LinInputs  int       // Inputs included in linearization
	LinOutputs int       // Outputs included in linearization
	LinOutJac  bool      // Include full Jacobians in linearization output (for debug)
	LinOutMod  bool      // Write module-level linearization output files in addition to output for full system?

	// Visualization
	WrVTK      int     // VTK visualization data output
	VTK_type   int     // Type of VTK visualization data
	VTK_fields bool    // Write mesh fields to VTK data files?
	VTK_fps    float64 // Frame rate for VTK output (frames per second) {will use closest integer multiple of DT}
	Defaults   map[string]struct{}
}

func NewFAST() *FAST {
	return &FAST{
		Defaults: map[string]struct{}{},
	}
}

func (s *FAST) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, FASTSchema, lines)
}

func ReadFAST(path string) (*FAST, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewFAST()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *FAST) Format() (text []byte, err error) {
	return formatText(s, FASTSchema)
}

func (s *FAST) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("FAST.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// InflowWind
type InflowWind struct {

	// InflowWind Input File
	Title string //

	// General
	Echo           bool      // Echo input data to <RootName>.ech (flag)
	WindType       int       // switch for wind file type
	PropagationDir float64   // Direction of wind propagation (meteorological rotation from aligned with X (positive rotates towards -Y) -- degrees) (not used for native Bladed format WindType=7)
	VFlowAng       float64   // Upflow angle (degrees) (not used for native Bladed format WindType=7)
	NWindVel       int       // Number of points to output the wind velocity
	WindVxiList    []float64 // List of coordinates in the inertial X direction
	WindVyiList    []float64 // List of coordinates in the inertial Y direction
	WindVziList    []float64 // List of coordinates in the inertial Z direction

	// Parameters for Steady Wind Conditions [used only for WindType = 1]
	HWindSpeed float64 // Horizontal wind speed
	RefHt      float64 // Reference height for horizontal wind speed
	PLExp      float64 // Power law exponent

	// Parameters for Uniform wind file [used only for WindType = 2]
	FileName_Uni string  // Filename of time series data for uniform wind field
	RefHt_Uni    float64 // Reference height for horizontal wind speed
	RefLength    float64 // Reference length for linear horizontal and vertical sheer

	// Parameters for Binary TurbSim Full-Field files [used only for WindType = 3]
	FileName_BTS string // Name of the Full field wind file to use (.bts)

	// Parameters for Binary Bladed-style Full-Field files [used only for WindType = 4 or WindType = 7]
	FileNameRoot string // WindType=4: Rootname of the full-field wind file to use (.wnd, .sum); WindType=7: name of the intermediate file with wind scaling values
	TowerFile    bool   // Have tower file (.twr) (flag) ignored when WindType = 7

	// Parameters for HAWC-format binary files  [Only used with WindType = 5] //===
	FileName_u string  // name of the file containing the u-component fluctuating wind (.bin)
	FileName_v string  // name of the file containing the v-component fluctuating wind (.bin)
	FileName_w string  // name of the file containing the w-component fluctuating wind (.bin)
	NX         int     // number of grids in the x direction (in the 3 files above)
	NY         int     // number of grids in the y direction (in the 3 files above)
	NZ         int     // number of grids in the z direction (in the 3 files above)
	DX         float64 // distance (in meters) between points in the x direction
	DY         float64 // distance (in meters) between points in the y direction
	DZ         float64 // distance (in meters) between points in the z direction
	RefHt_Hawc float64 // reference height; the height (in meters) of the vertical center of the grid

	// Scaling parameters for turbulence
	ScaleMethod int     // Turbulence scaling method
	SFx         float64 // Turbulence scaling factor for the x direction [ScaleMethod=1]
	SFy         float64 // Turbulence scaling factor for the y direction [ScaleMethod=1]
	SFz         float64 // Turbulence scaling factor for the z direction [ScaleMethod=1]
	SigmaFx     float64 // Turbulence standard deviation to calculate scaling from in x direction [ScaleMethod=2]
	SigmaFy     float64 // Turbulence standard deviation to calculate scaling from in y direction [ScaleMethod=2]
	SigmaFz     float64 // Turbulence standard deviation to calculate scaling from in z direction [ScaleMethod=2]

	// Mean wind profile parameters (added to HAWC-format files)
	URef        float64 // Mean u-component wind speed at the reference height
	WindProfile int     // Wind profile type
	PLExp_Hawc  float64 // Power law exponent (used for PL wind profile type only)
	Z0          float64 // Surface roughness length (used for LG wind profile type only)
	XOffset     float64 // Initial offset in +x direction (shift of wind box)

	// Output
	SumPrint bool     // Print summary data to <RootName>.IfW.sum (flag)
	OutList  []string // The next line(s) contains a list of output parameters.  See OutListParameters.xlsx for a listing of available output channels
	Defaults map[string]struct{}
}

func NewInflowWind() *InflowWind {
	return &InflowWind{
		Defaults: map[string]struct{}{},
	}
}

func (s *InflowWind) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, InflowWindSchema, lines)
}

func ReadInflowWind(path string) (*InflowWind, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewInflowWind()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *InflowWind) Format() (text []byte, err error) {
	return formatText(s, InflowWindSchema)
}

func (s *InflowWind) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("InflowWind.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// ServoDyn
type ServoDyn struct {

	// ServoDyn Input File
	Title string //

	// Simulation Control
	Echo bool    // Echo input data to <RootName>.ech (flag)
	DT   float64 // Communication interval for controllers (s) (or "default")

	// Pitch Control
	PCMode     int     // Pitch control mode {0: none, 3: user-defined from routine PitchCntrl, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} (switch)
	TPCOn      float64 // Time to enable active pitch control (s) [unused when PCMode=0]
	TPitManS1  float64 // Time to start override pitch maneuver for blade 1 and end standard pitch control (s)
	TPitManS2  float64 // Time to start override pitch maneuver for blade 2 and end standard pitch control (s)
	TPitManS3  float64 // Time to start override pitch maneuver for blade 3 and end standard pitch control (s) [unused for 2 blades]
	PitManRat1 float64 // Pitch rate at which override pitch maneuver heads toward final pitch angle for blade 1 (deg/s)
	PitManRat2 float64 // Pitch rate at which override pitch maneuver heads toward final pitch angle for blade 2 (deg/s)
	PitManRat3 float64 // Pitch rate at which override pitch maneuver heads toward final pitch angle for blade 3 (deg/s) [unused for 2 blades]
	BlPitchF1  float64 // Blade 1 final pitch for pitch maneuvers (degrees)
	BlPitchF2  float64 // Blade 2 final pitch for pitch maneuvers (degrees)
	BlPitchF3  float64 // Blade 3 final pitch for pitch maneuvers (degrees) [unused for 2 blades]

	// Generator And Torque Control
	VSContrl int     // Variable-speed control mode {0: none, 1: simple VS, 3: user-defined from routine UserVSCont, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} (switch)
	GenModel int     // Generator model {1: simple, 2: Thevenin, 3: user-defined from routine UserGen} (switch) [used only when VSContrl=0]
	GenEff   float64 // Generator efficiency [ignored by the Thevenin and user-defined generator models] (%)
	GenTiStr bool    // Method to start the generator {T: timed using TimGenOn, F: generator speed using SpdGenOn} (flag)
	GenTiStp bool    // Method to stop the generator {T: timed using TimGenOf, F: when generator power = 0} (flag)
	SpdGenOn float64 // Generator speed to turn on the generator for a startup (HSS speed) (rpm) [used only when GenTiStr=False]
	TimGenOn float64 // Time to turn on the generator for a startup (s) [used only when GenTiStr=True]
	TimGenOf float64 // Time to turn off the generator (s) [used only when GenTiStp=True]

	// Simple Variable-Speed Torque Control
	VS_RtGnSp float64 // Rated generator speed for simple variable-speed generator control (HSS side) (rpm) [used only when VSContrl=1]
	VS_RtTq   float64 // Rated generator torque/constant generator torque in Region 3 for simple variable-speed generator control (HSS side) (N-m) [used only when VSContrl=1]
	VS_Rgn2K  float64 // Generator torque constant in Region 2 for simple variable-speed generator control (HSS side) (N-m/rpm^2) [used only when VSContrl=1]
	VS_SlPc   float64 // Rated generator slip percentage in Region 2 1/2 for simple variable-speed generator control (%) [used only when VSContrl=1]

	// Simple Induction Generator
	SIG_SlPc float64 // Rated generator slip percentage (%) [used only when VSContrl=0 and GenModel=1]
	SIG_SySp float64 // Synchronous (zero-torque) generator speed (rpm) [used only when VSContrl=0 and GenModel=1]
	SIG_RtTq float64 // Rated torque (N-m) [used only when VSContrl=0 and GenModel=1]
	SIG_PORt float64 // Pull-out ratio (Tpullout/Trated) (-) [used only when VSContrl=0 and GenModel=1]

	// Thevenin-Equivalent Induction Generator
	TEC_Freq float64 // Line frequency [50 or 60] (Hz) [used only when VSContrl=0 and GenModel=2]
	TEC_NPol int     // Number of poles [even integer > 0] (-) [used only when VSContrl=0 and GenModel=2]
	TEC_SRes float64 // Stator resistance (ohms) [used only when VSContrl=0 and GenModel=2]
	TEC_RRes float64 // Rotor resistance (ohms) [used only when VSContrl=0 and GenModel=2]
	TEC_VLL  float64 // Line-to-line RMS voltage (volts) [used only when VSContrl=0 and GenModel=2]
	TEC_SLR  float64 // Stator leakage reactance (ohms) [used only when VSContrl=0 and GenModel=2]
	TEC_RLR  float64 // Rotor leakage reactance (ohms) [used only when VSContrl=0 and GenModel=2]
	TEC_MR   float64 // Magnetizing reactance (ohms) [used only when VSContrl=0 and GenModel=2]

	// High-Speed Shaft Brake
	HSSBrMode int     // HSS brake model {0: none, 1: simple, 3: user-defined from routine UserHSSBr, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} (switch)
	THSSBrDp  float64 // Time to initiate deployment of the HSS brake (s)
	HSSBrDT   float64 // Time for HSS-brake to reach full deployment once initiated (sec) [used only when HSSBrMode=1]
	HSSBrTqF  float64 // Fully deployed HSS-brake torque (N-m)

	// Nacelle-Yaw Control
	YCMode    int     // Yaw control mode {0: none, 3: user-defined from routine UserYawCont, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} (switch)
	TYCOn     float64 // Time to enable active yaw control (s) [unused when YCMode=0]
	YawNeut   float64 // Neutral yaw position--yaw spring force is zero at this yaw (degrees)
	YawSpr    float64 // Nacelle-yaw spring constant (N-m/rad)
	YawDamp   float64 // Nacelle-yaw damping constant (N-m/(rad/s))
	TYawManS  float64 // Time to start override yaw maneuver and end standard yaw control (s)
	YawManRat float64 // Yaw maneuver rate (in absolute value) (deg/s)
	NacYawF   float64 // Final yaw angle for override yaw maneuvers (degrees)

	// Aerodynamic Flow Control
	AfCmode   int     // Airfoil control mode {0: none, 1: cosine wave cycle, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} (switch)
	AfC_Mean  float64 // Mean level for cosine cycling or steady value (-) [used only with AfCmode==1]
	AfC_Amp   float64 // Amplitude for for cosine cycling of flap signal (-) [used only with AfCmode==1]
	AfC_Phase float64 // Phase relative to the blade azimuth (0 is vertical) for for cosine cycling of flap signal (deg) [used only with AfCmode==1]

	// Structural Control
	NumBStC   int    // Number of blade structural controllers (integer)
	BStCfiles string // Name of the files for blade structural controllers (quoted strings) [unused when NumBStC==0]
	NumNStC   int    // Number of nacelle structural controllers (integer)
	NStCfiles string // Name of the files for nacelle structural controllers (quoted strings) [unused when NumNStC==0]
	NumTStC   int    // Number of tower structural controllers (integer)
	TStCfiles string // Name of the files for tower structural controllers (quoted strings) [unused when NumTStC==0]
	NumSStC   int    // Number of substructure structural controllers (integer)
	SStCfiles string // Name of the files for substructure structural controllers (quoted strings) [unused when NumSStC==0]

	// Cable Control
	CCmode int // Cable control mode {0: none, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} (switch)

	// BLADED Interface
	DLL_FileName string  // Name/location of the dynamic library {.dll [Windows] or .so [Linux]} in the Bladed-DLL format (-) [used only with Bladed Interface]
	DLL_InFile   string  // Name of input file sent to the DLL (-) [used only with Bladed Interface]
	DLL_ProcName string  // Name of procedure in DLL to be called (-) [case sensitive; used only with DLL Interface]
	DLL_DT       float64 // Communication interval for dynamic library (s) (or "default") [used only with Bladed Interface]
	DLL_Ramp     bool    // Whether a linear ramp should be used between DLL_DT time steps [introduces time shift when true] (flag) [used only with Bladed Interface]
	BPCutoff     float64 // Cutoff frequency for low-pass filter on blade pitch from DLL (Hz) [used only with Bladed Interface]
	NacYaw_North float64 // Reference yaw angle of the nacelle when the upwind end points due North (deg) [used only with Bladed Interface]
	Ptch_Cntrl   int     // Record 28: Use individual pitch control {0: collective pitch; 1: individual pitch control} (switch) [used only with Bladed Interface]
	Ptch_SetPnt  float64 // Record  5: Below-rated pitch angle set-point (deg) [used only with Bladed Interface]
	Ptch_Min     float64 // Record  6: Minimum pitch angle (deg) [used only with Bladed Interface]
	Ptch_Max     float64 // Record  7: Maximum pitch angle (deg) [used only with Bladed Interface]
	PtchRate_Min float64 // Record  8: Minimum pitch rate (most negative value allowed) (deg/s) [used only with Bladed Interface]
	PtchRate_Max float64 // Record  9: Maximum pitch rate  (deg/s) [used only with Bladed Interface]
	Gain_OM      float64 // Record 16: Optimal mode gain (Nm/(rad/s)^2) [used only with Bladed Interface]
	GenSpd_MinOM float64 // Record 17: Minimum generator speed (rpm) [used only with Bladed Interface]
	GenSpd_MaxOM float64 // Record 18: Optimal mode maximum speed (rpm) [used only with Bladed Interface]
	GenSpd_Dem   float64 // Record 19: Demanded generator speed above rated (rpm) [used only with Bladed Interface]
	GenTrq_Dem   float64 // Record 22: Demanded generator torque above rated (Nm) [used only with Bladed Interface]
	GenPwr_Dem   float64 // Record 13: Demanded power (W) [used only with Bladed Interface]

	// BLADED Interface Torque-Speed Look-Up Table
	DLL_NumTrq int                 // Record 26: No. of points in torque-speed look-up table {0 = none and use the optimal mode parameters; nonzero = ignore the optimal mode PARAMETERs by setting Record 16 to 0.0} (-) [used only with Bladed Interface]
	GenSpdTrq  []ServoDynGenSpdTrq //

	// Output
	SumPrint bool     // Print summary data to <RootName>.sum (flag) (currently unused)
	OutFile  int      // Switch to determine where output will be placed: {1: in module output file only; 2: in glue code output file only; 3: both} (currently unused)
	TabDelim bool     // Use tab delimiters in text tabular output file? (flag) (currently unused)
	OutFmt   string   // Format used for text tabular output (except time).  Resulting field should be 10 characters. (quoted string) (currently unused)
	TStart   float64  // Time to begin tabular output (s) (currently unused)
	OutList  []string // The next line(s) contains a list of output parameters.  See OutListParameters.xlsx for a listing of available output channels, (-)
	Defaults map[string]struct{}
}

// ServoDynGenSpdTrq
type ServoDynGenSpdTrq struct {
	GenSpd_TLU []float64 // GenSpd_TLU
	GenTrq_TLU []float64 // GenTrq_TLU
}

func NewServoDyn() *ServoDyn {
	return &ServoDyn{
		Defaults: map[string]struct{}{},
	}
}

func (s *ServoDyn) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, ServoDynSchema, lines)
}

func ReadServoDyn(path string) (*ServoDyn, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewServoDyn()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *ServoDyn) Format() (text []byte, err error) {
	return formatText(s, ServoDynSchema)
}

func (s *ServoDyn) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("ServoDyn.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}

// TurbSim
type TurbSim struct {

	// TurbSim Input File
	Title string //

	// Runtime Options
	Echo      bool   // Echo input data to <RootName>.ech (flag)
	RandSeed1 int    // First random seed  (-2147483648 to 2147483647)
	RandSeed2 string // Second random seed (-2147483648 to 2147483647) for intrinsic pRNG, or an alternative pRNG: "RanLux" or "RNSNLW"
	WrBHHTP   bool   // Output hub-height turbulence parameters in binary form?  (Generates RootName.bin)
	WrFHHTP   bool   // Output hub-height turbulence parameters in formatted form?  (Generates RootName.dat)
	WrADHH    bool   // Output hub-height time-series data in AeroDyn form?  (Generates RootName.hh)
	WrADFF    bool   // Output full-field time-series data in TurbSim/AeroDyn form? (Generates RootName.bts)
	WrBLFF    bool   // Output full-field time-series data in BLADED/AeroDyn form?  (Generates RootName.wnd)
	WrADTWR   bool   // Output tower time-series data? (Generates RootName.twr)
	WrFMTFF   bool   // Output full-field time-series data in formatted (readable) form?  (Generates RootName.u, RootName.v, RootName.w)
	WrACT     bool   // Output coherent turbulence time steps in AeroDyn form? (Generates RootName.cts)
	Clockwise bool   // Clockwise rotation looking downwind? (used only for full-field binary files - not necessary for AeroDyn)
	ScaleIEC  int    // Scale IEC turbulence models to exact target standard deviation? [0=no additional scaling; 1=use hub scale uniformly; 2=use individual scales]

	// -

	// Turbine/Model Specifications
	NumGrid_Z    int     // Vertical grid-point matrix dimension
	NumGrid_Y    int     // Horizontal grid-point matrix dimension
	TimeStep     float64 // Time step [seconds]
	AnalysisTime float64 // Length of analysis time series [seconds] (program will add time if necessary: AnalysisTime = MAX(AnalysisTime, UsableTime+GridWidth/MeanHHWS) )
	UsableTime   float64 // Usable length of output time series [seconds] (program will add GridWidth/MeanHHWS seconds unless UsableTime is "ALL")
	HubHt        float64 // Hub height [m] (should be > 0.5*GridHeight)
	GridHeight   float64 // Grid height [m]
	GridWidth    float64 // Grid width [m] (should be >= 2*(RotorRadius+ShaftLength))
	VFlowAng     float64 // Vertical mean flow (uptilt) angle [degrees]
	HFlowAng     float64 // Horizontal mean flow (skew) angle [degrees]

	// -

	// Meteorological Boundary Conditions
	TurbModel       string  // Turbulence model ("IECKAI","IECVKM","GP_LLJ","NWTCUP","SMOOTH","WF_UPW","WF_07D","WF_14D","TIDAL","API","USRINP","TIMESR", or "NONE")
	UserFile        string  // Name of the file that contains inputs for user-defined spectra or time series inputs (used only for "USRINP" and "TIMESR" models)
	IECstandard     string  // Number of IEC 61400-x standard (x=1,2, or 3 with optional 61400-1 edition number (i.e. "1-Ed2") )
	IECturbc        string  // IEC turbulence characteristic ("A", "B", "C" or the turbulence intensity in percent) ("KHTEST" option with NWTCUP model, not used for other models)
	IEC_WindType    string  // IEC turbulence type ("NTM"=normal, "xETM"=extreme turbulence, "xEWM1"=extreme 1-year wind, "xEWM50"=extreme 50-year wind, where x=wind turbine class 1, 2, or 3)
	ETMc            float64 // IEC Extreme Turbulence Model "c" parameter [m/s]
	WindProfileType string  // Velocity profile type ("LOG";"PL"=power law;"JET";"H2L"=Log law for TIDAL model;"API";"USR";"TS";"IEC"=PL on rotor disk, LOG elsewhere; or "default")
	ProfileFile     string  // Name of the file that contains input profiles for WindProfileType="USR" and/or TurbModel="USRVKM" [-]
	RefHt           float64 // Height of the reference velocity (URef) [m]
	URef            float64 // Mean (total) velocity at the reference height [m/s] (or "default" for JET velocity profile) [must be 1-hr mean for API model; otherwise is the mean over AnalysisTime seconds]
	ZJetMax         float64 // Jet height [m] (used only for JET velocity profile, valid 70-490 m)
	PLExp           float64 // Power law exponent [-] (or "default")
	Z0              float64 // Surface roughness length [m] (or "default")

	// -

	// Non-IEC Meteorological Boundary Conditions
	Latitude float64 // Site latitude [degrees] (or "default")
	RICH_NO  float64 // Gradient Richardson number [-]
	UStar    float64 // Friction or shear velocity [m/s] (or "default")
	ZI       float64 // Mixing layer depth [m] (or "default")
	PC_UW    float64 // Hub mean uw Reynolds stress [m^2/s^2] (or "default" or "none")
	PC_UV    float64 // Hub mean uv Reynolds stress [m^2/s^2] (or "default" or "none")
	PC_VW    float64 // Hub mean vw Reynolds stress [m^2/s^2] (or "default" or "none")

	// -

	// Spatial Coherence Parameters
	SCMod1  string  // u-component coherence model ("GENERAL", "IEC", "API", "NONE", or "default")
	SCMod2  string  // v-component coherence model ("GENERAL", "IEC", "NONE", or "default")
	SCMod3  string  // w-component coherence model ("GENERAL", "IEC", "NONE", or "default")
	InCDec1 float64 // u-component coherence parameters for general or IEC models [-, m^-1] (e.g. "10.0  0.3e-3" in quotes) (or "default")
	InCDec2 float64 // v-component coherence parameters for general or IEC models [-, m^-1] (e.g. "10.0  0.3e-3" in quotes) (or "default")
	InCDec3 float64 // w-component coherence parameters for general or IEC models [-, m^-1] (e.g. "10.0  0.3e-3" in quotes) (or "default")
	CohExp  float64 // Coherence exponent for general model [-] (or "default")

	// -

	// Coherent Turbulence Scaling Parameters
	CTEventPath string  // Name of the path where event data files are located
	CTEventFile string  // Type of event files ("LES", "DNS", or "RANDOM")
	Randomize   bool    // Randomize the disturbance scale and locations? (true/false)
	DistScl     float64 // Disturbance scale [-] (ratio of event dataset height to rotor disk). (Ignored when Randomize = true.)
	CTLy        float64 // Fractional location of tower centerline from right [-] (looking downwind) to left side of the dataset. (Ignored when Randomize = true.)
	CTLz        float64 // Fractional location of hub height from the bottom of the dataset. [-] (Ignored when Randomize = true.)
	CTStartTime float64 // Minimum start time for coherent structures in RootName.cts [seconds]
	Defaults    map[string]struct{}
}

func NewTurbSim() *TurbSim {
	return &TurbSim{
		Defaults: map[string]struct{}{},
	}
}

func (s *TurbSim) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, TurbSimSchema, lines)
}

func ReadTurbSim(path string) (*TurbSim, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := NewTurbSim()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *TurbSim) Format() (text []byte, err error) {
	return formatText(s, TurbSimSchema)
}

func (s *TurbSim) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("TurbSim.Format(): %w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%s': %w", path, err)
	}
	return nil
}
