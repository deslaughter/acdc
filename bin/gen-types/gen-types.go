package main

import (
	"bytes"
	"sort"

	"github.com/deslaughter/acdc/input"

	"fmt"
	"go/format"
	"io"
	"os"
	"strings"
)

func main() {

	w := &bytes.Buffer{}
	w.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	w.WriteString("package input\n\n")
	w.WriteString("import (\n\t\"fmt\"\n\t\"os\"\n)\n")

	names := []string{}
	for name := range input.Schemas {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		generateStruct(w, name, input.Schemas[name])
	}

	contents, err := format.Source(w.Bytes())
	if err != nil {
		contents = w.Bytes()
	}
	os.WriteFile("structs.go", contents, 0777)
}

func generateStruct(w io.Writer, name string, entries []input.SchemaEntry) {

	// Generate structure
	fmt.Fprintf(w, "// %s\n", name)
	fmt.Fprintf(w, "type %s struct {\n", name)
	for _, entry := range entries {
		if entry.Heading != "" {
			fmt.Fprintf(w, "\n// %s\n", entry.Heading)
			continue
		}
		Type := strings.Repeat("[]", entry.Dims) + string(entry.Type)
		fmt.Fprintf(w, "\t%s %s // %s\n", entry.Field, Type, entry.Desc)
	}
	fmt.Fprintf(w, "Defaults map[string]struct{}\n")
	fmt.Fprintf(w, "}\n\n")

	// Generate table structures
	for _, entry := range entries {
		if entry.Table != nil {
			fmt.Fprintf(w, "// %s\n", entry.Type)
			fmt.Fprintf(w, "type %s struct {\n", entry.Type)
			for _, column := range entry.Table.Columns {
				Type := strings.Repeat("[]", column.Dims) + string(column.Type)
				fmt.Fprintf(w, "\t%s %s // %s\n", column.Field, Type, column.Desc)
			}
			fmt.Fprintf(w, "}\n\n")
		}
	}

	// Generate new function to set default values
	fmt.Fprintf(w, "func New%s() *%s {\n", name, name)
	fmt.Fprintf(w, "\treturn &%s{\n", name)
	for _, entry := range entries {
		if entry.Default != nil {
			fmt.Fprintf(w, "\t\t%s: %v,\n", entry.Field, entry.Default)
		}
	}
	fmt.Fprintf(w, "\t\tDefaults: map[string]struct{}{},\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, encodingTemplate, name)
}

var encodingTemplate = `
func (s *%[1]s) Parse(text []byte) error {
	lines, err := splitLines(text)
	if err != nil {
		return err
	}
	return parseText(s, %[1]sSchema, lines)
}

func Read%[1]s(path string) (*%[1]s, error) {
	text, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := New%[1]s()
	if err = s.Parse(text); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *%[1]s) Format() (text []byte, err error) {
	return formatText(s, %[1]sSchema)
}

func (s *%[1]s) Write(path string) error {
	text, err := s.Format()
	if err != nil {
		return fmt.Errorf("%[1]s.Format(): %%w", err)
	}
	if err := os.WriteFile(path, text, 0777); err != nil {
		return fmt.Errorf("error writing '%%s': %%w", path, err)
	}
	return nil
}
`
